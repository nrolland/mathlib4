/-
Copyright (c) 2024 Nicolas Rolland. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Nicolas Rolland
-/
import Mathlib.CategoryTheory.Category.Cat
import Mathlib.CategoryTheory.Adjunction.Basic
import Mathlib.Combinatorics.Quiver.ConnectedComponent

universe v u
namespace CategoryTheory.Cat

variable {C D : Cat}
variable {a b c : C}
variable (F : C ⥤ D)

/-! # Relation induced by a category

A category induces a relation on its objects
Two objects are connected if there is an arrow between them.
This relation is not an equivalence but can be turned into one.
-/

/-- `EqvGenCat C` is the equivalence relation generated by `C`. -/
inductive EqvGenCat : C → C → Prop
  | rel : ∀ (x y : C), C.str.toQuiver.Hom x y → EqvGenCat x y
  | symm : ∀ (x y : C), EqvGenCat x y → EqvGenCat y x
  | trans : ∀ (x y z : C), EqvGenCat x y → EqvGenCat y z → EqvGenCat x z

theorem EqvGenCat.is_equivalence (C : CategoryTheory.Cat) :
    _root_.Equivalence (@CategoryTheory.Cat.EqvGenCat C) :=
    _root_.Equivalence.mk
      (fun x => Cat.EqvGenCat.rel _ _ (C.str.id x))
      (fun r => CategoryTheory.Cat.EqvGenCat.symm _ _  r)
      (fun r s => CategoryTheory.Cat.EqvGenCat.trans _ _ _  r s )


inductive NormEqvGenCat : C → C → Prop
  | rel : ∀ (x y : C), C.str.toQuiver.Hom x y → NormEqvGenCat x y
  | symm : ∀ (x y : C), C.str.toQuiver.Hom x y → NormEqvGenCat y x
  | trans : ∀ (x y z : C), NormEqvGenCat x y → NormEqvGenCat y z → NormEqvGenCat x z




/-- `EqvGenCat.Setoid C` is the setoid generated by the category `C`. -/
def EqvGenCat.Setoid (C : Cat) : Setoid C :=
   Setoid.mk EqvGenCat (EqvGenCat.is_equivalence C)

def isConnected (a : C ) (b : C) : Prop := Nonempty (a ⟶ b) -- ∃ (_ : a ⟶ b, True)

def toEqvGen  (h: EqvGenCat a b) : (EqvGen.Setoid isConnected).r a b  :=
    h.rec
    (fun _ _ f => EqvGen.rel _ _ ⟨f⟩)
    (fun _ _ _ h => EqvGen.symm _ _ h)
    (fun _ _ _ _ _ hf hg => EqvGen.trans _ _ _ hf hg)

def toEqvGenCat (h : (EqvGen.Setoid isConnected).r a b) : EqvGenCat a b  := by
  induction h
  case rel h => exact h.elim (EqvGenCat.rel _ _ )
  case refl x => exact EqvGenCat.rel _ _ (𝟙 _)
  case symm _ _ _ ih => exact EqvGenCat.symm _ _ ih
  case trans _ _ _ _ ig ih => exact EqvGenCat.trans _ _ _ ig ih



/-- The relation is transported by functors -/
lemma transport (h : EqvGenCat a b) : EqvGenCat (F.obj a) (F.obj b) :=
  h.rec
    (fun _ _ f => EqvGenCat.rel _ _ (F.map f))
    (fun _ _ _ h =>  EqvGenCat.symm _ _ h)
    (fun _ _ _ _ _ mf mg  => EqvGenCat.trans _ _ _ mf mg)




-- section

-- variable {α : Type u}
-- variable (r : α → α → Prop)

-- /-- `EqvGen r` is the equivalence relation generated by `r`. -/
-- inductive EqvGen : α → α → Prop
--   | rel : ∀ x y, r x y → EqvGen x y
--   | refl : ∀ x, EqvGen x x
--   | symm : ∀ x y, EqvGen x y → EqvGen y x
--   | trans : ∀ x y z, EqvGen x y → EqvGen y z → EqvGen x z

-- theorem EqvGen.is_equivalence : Equivalence (@EqvGen α r) :=
--   Equivalence.mk EqvGen.refl (EqvGen.symm _ _) (EqvGen.trans _ _ _)

-- /-- `EqvGen.Setoid r` is the setoid generated by a relation `r`.

-- The motivation for this definition is that `Quot r` behaves like `Quotient (EqvGen.Setoid r)`,
-- see for example `Quot.exact` and `Quot.EqvGen_sound`.
-- -/
-- def EqvGen.Setoid : Setoid α :=
--   Setoid.mk _ (EqvGen.is_equivalence r)

-- theorem Quot.exact {a b : α} (H : Quot.mk r a = Quot.mk r b) : EqvGen r a b :=
--   @Quotient.exact _ (EqvGen.Setoid r) a b (congrArg
--     (Quot.lift (Quotient.mk (EqvGen.Setoid r)) (fun x y h ↦ Quot.sound (EqvGen.rel x y h))) H)

-- theorem Quot.EqvGen_sound {r : α → α → Prop} {a b : α} (H : EqvGen r a b) :
--     Quot.mk r a = Quot.mk r b :=
--   EqvGen.rec
--     (fun _ _ h ↦ Quot.sound h)
--     (fun _ ↦ rfl)
--     (fun _ _ _ IH ↦ Eq.symm IH)
--     (fun _ _ _ _ _ IH₁ IH₂ ↦ Eq.trans IH₁ IH₂)
--     H

-- end


/-! ## Equivalence relation induced by a category

To make the previous relation is not an equivalence.
One can take its equivalence closure, under which two objects are connected
iif there is a zigzag of arrows between them.
-/
abbrev isConnectedByZigZag : C → C → Prop := EqvGen isConnected
abbrev isConnectedByZigZag' (C:Cat) : Setoid C := Quiver.zigzagSetoid C


private def connectByZigZag (f : a ⟶ b) : isConnectedByZigZag a b := ⟨f⟩ |>  EqvGen.rel _ _

lemma transportZigZag (h : isConnectedByZigZag a b) : isConnectedByZigZag (F.obj a) (F.obj b) := by
  induction h
  case rel h => exact (EqvGen.rel _ _ (transport F h))
  case refl => exact EqvGen.refl _
  case symm w => exact EqvGen.symm _ _ w
  case trans f g => exact EqvGen.trans _ _ _ f g


-- lemma transportZigZag':  ((isConnectedByZigZag' C).r a b) -> (isConnectedByZigZag' D).r (F.obj a) (F.obj b)
--   | ⟨h⟩ => (match h with
--             | .nil =>  Quiver.Path.nil
--             | .cons p f =>
--                 match f with
--                 | Sum.inl f => Quiver.Path.cons (transportZigZag' ⟨p⟩) (Sum.inl (F.map f))
--                 | Sum.inr f =>  Quiver.Path.cons (transportZigZag' ⟨p⟩) (Sum.inr (F.map f)))
--           |> Nonempty.intro

lemma transportZigZag':  ((isConnectedByZigZag' C).r a b) -> (isConnectedByZigZag' D).r (F.obj a) (F.obj b)
  | ⟨h⟩ => by induction h
              · exact Nonempty.intro Quiver.Path.nil
              · sorry


--- Quotient based computation
def catisSetoid (C :Cat) : Setoid C := EqvGen.Setoid isConnected

#check fun (C :Cat)  => C.str.toQuiver

-- Ensemble des composantes d'une categorie
abbrev ccSet  (C : Cat) := Quotient (catisSetoid C)
abbrev wccSet  (C : Cat) := Quiver.WeaklyConnectedComponent C

-- Transport d'un x vers sa composante
def toCC (x : C) : ccSet C := Quotient.mk (catisSetoid C) x
def toCC' (x : C): wccSet C := Quotient.mk (Quiver.zigzagSetoid C) x


private def fmap {X Y : Cat} (F : X ⟶ Y) : (ccSet X) → (ccSet Y) :=
  Quotient.lift
    (s:= catisSetoid X)
    (toCC ∘ F.obj  : X → ccSet Y)
    (fun _ _ => Quot.sound ∘ transportZigZag F )


private abbrev liftedMk {α} (s : Setoid α)  :=
  Quotient.lift (Quotient.mk s) (fun _ _ => Quotient.sound)


/- The functor for connected components -/
def connectedComponents : Cat.{v, u} ⥤ Type u where
  obj C := ccSet C -- maps a category to its set of CC
  map F := fmap F  -- transport a functor to a function beetwen CC
  map_id X := by calc
      fmap (𝟙 X) =  liftedMk (catisSetoid X) := (rfl : fmap (𝟙 X) = liftedMk (catisSetoid X))
      _          = fun x => x    := funext (fun xt => by obtain ⟨x,h⟩ := Quotient.exists_rep xt
                                                         simp [h.symm])
      _          = 𝟙 (ccSet X)   := by rfl
  map_comp f g := by simp; funext xt; obtain ⟨_,h⟩ := Quotient.exists_rep xt;
                     simp [h.symm];rfl

def releqq (f : a ⟶ b) : toCC a = toCC b := connectByZigZag f |> .rel _ _ |> Quot.EqvGen_sound


def eq_of_zigzag (X) {a b : typeToCat.obj X } (h : isConnectedByZigZag a b) : a.as = b.as := by
  induction h with
  | rel _ _ h => let ⟨f⟩ := h;exact Discrete.eq_of_hom f
  | refl => rfl
  | symm _ _ _ ih => exact ih.symm
  | trans _ _ _ _ _ ih1 ih2 => exact ih1.trans ih2

def transportZigzag (F : C ⥤ D) (h : isConnectedByZigZag a b)
             : isConnectedByZigZag (F.obj a) ( F.obj b) := by
  induction h with
  | rel _ _ h => let ⟨f⟩ := h; exact EqvGen.rel _ _  ⟨F.map f⟩
  | refl => exact EqvGen.refl _
  | symm _ _ _ ih => exact EqvGen.symm _ _ ih
  | trans _ _ _ _ _ ih1 ih2 => exact EqvGen.trans _ _ _ ih1 ih2


end CategoryTheory.Cat
